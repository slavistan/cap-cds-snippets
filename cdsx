#!/usr/bin/env zsh

# set -- watch --pre="sleep 5 &"

TAIL=${0:t}

usage() {
  printf \
"\033[1mNAME\033[0m
\t$TAIL - Extension to SAP's cds cli.

\033[1mSYNOPSIS\033[0m
\t$TAIL watch [OPTIONS]

\033[1mOPTIONS\033[0m
\t-l | --watchlist
\t\tPrint newline-sep'd list of watched files and exit.

\t--pre=<CMD>
\t\tExecutes a command prior to serving the project. Can be invoked multiple
\t\ttimes to run multiple command in the order of their declaration. Execution
\t\tterminates if any command in the chain fails.

\t\tExample: \033[3;32m$TAIL --pre='rm ./sqlite.db' --pre='cds deploy'\033[0m
\t\twill execute \033[3;32mrm ./sqlite.db && cds deploy\033[0m prior to serving the project.

\t-d | --redeploy
\t\tRedeploy to database on file change. Equivalent to --pre='cds deploy'.
\t\tExecuted as the very last command when used alongside other '--pre=...'
\t\toptions.
"

  exit
}

# return if a flag is set
isflagset() {
  echo "$FLAGS" | grep -qF "$1"
}

# returns watchlist
watch/watchlist() {
  find '.' -type f                \
    -not -path '*/\.*'            \
    -not -path '*/node_modules/*' \
    -not -name '*.db'
}

# parse cli options for watch subcommand
watch/parseopt() {
  shift
  local -a opts
  local -a precmds
  local -a postcmds
  zparseopts -a opts -- l d -pre+:=precmds -post+=postcmds

  # concatenate all flags to a single string FLAGS
  # TODO
  #   [ ]: add --redeploy and --watchlist long alternatives
  FLAGS=$(echo "$opts" | tr -d ' -')

  # store precmds as array PRECMDS
  PRECMDS=()
  for ((ii = 2; ii <= ${#precmds}; ii += 2)); do
    PRECMDS+=$(echo $precmds[$ii] | sed 's/^=//g')
  done

  # store postcmds as array POSTCMDS
  POSTCMDS=()
  for ((ii = 2; ii <= ${#postcmds}; ii += 2)); do
    POSTCMDS+=$(echo $postcmds[$ii] | sed 's/^=//g')
  done
}

# post-war cleanup
cleanup() {
  rm -rf "$TMPDIR"
  # kill spawned subshell and its children. Required when CTRL+C'ing the
  # script. Otherwise the watcher subshell will spawn zombies :(
  # Probably has to do with the way entr spawns process groups
  if ps $WATCHERPID > /dev/null; then 
    kill $(pgrep -P $WATCHERPID) $WATCHERPID
  fi
  exit
}

case "$1" in
  help|-h|--help)
    usage ;;
  watch)
    watch/parseopt "$@"

    # -l | --watchlist: print watchlist end exit
    isflagset l && watch/watchlist && exit

    # -d | --pre=<cmd>: build command string and run
    entrcmd="cds serve"
    isflagset d && entrcmd="cds deploy && $entrcmd"
    for ((ii = ${#PRECMDS}; ii >= 1; ii -= 1)); do
      entrcmd="($PRECMDS[$ii]) && $entrcmd"
    done

    TMPDIR=$(mktemp -d -p /tmp cdsx-fifo-XXXXXX)
    echo "tmpdir = $TMPDIR"
    FIFO="$TMPDIR/fifo"
    mkfifo "$FIFO"
    cleanup='rm -rf $tmpdir; echo cleanup'
    trap "cleanup" 0 1 15 INT

    MASK='launched in:'
    (
      echo "$(date): watcher started" > /dev/pts/2
      cat "$FIFO" | grep -qE "$MASK"
      # TODO: execute --post commands here
      echo "$(date): triggered" > /dev/pts/2
      cat "$FIFO" > /dev/null
      echo "$(date): watcher terminated" > /dev/pts/2
    ) &
    WATCHERPID=$!
    echo "$WATCHERPID"

    watch/watchlist | entr -rs "$entrcmd" | tee "$FIFO"

  ;;
  *)
    usage
    ;;
esac
